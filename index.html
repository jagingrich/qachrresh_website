<!DOCTYPE html>
<html>
<head>
    <title>Qach Rresh Interactive Site Plan</title>
    <!--
    <link rel="icon" href="https://raw.githubusercontent.com/jagingrich/samo_website/main/Data/mapIcons/SamoWebsite_Icon.png"
          type="image/x-icon">
          -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>

    <script src="./Data/mapCode/formatText_js.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: rgb(0, 0, 0);
        }
        #map {
            height: 100%;
            width: 100%;
            background-color: #000000;
            left: 0;
            position: absolute;
        }

        #loading {
            position: absolute;
            z-index: 3000;
            height: 100%;
            width: 100%;
            background: black;
        }

        #progressBox {
            width: 20%;
            margin-left: 40%;
            top: 45%;
            height: 15px;
            position: absolute;
            border-radius: 5px;
            border-color: gray;
            border-style: solid;
            border-width: 1px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.65);
        }

        #progressBg {
            width: 100%;
            height: 15px;
            background-color: #727272;
            color: white;
            border-radius: inherit;
            border-width: 0px;
        }

        #progressBar {
            width: 0%;
            height: 15px;
            background-color: #0d9700;
            color: white;
            border-radius: inherit;
            border-width: 0px;
        }

        .sidebar {
            height: 100%;
            position: absolute;
            background-color: rgb(0, 0, 0);
            color: rgb(255, 255, 255);
            overflow: auto;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
            padding: 10px;
            z-index: 2000;
            font-family: Helvetica, Arial, sans-serif;
            line-height: 1.5;
        }
        #sidebar-left{
            left: 0;
            width: 0;
            transform: scaleX(-1);
        }
        #sidebar-right{
            right: 0;
            width: 0;
        }

        #leaflet-refresh-button {
            background-color: rgb(45, 45, 45, 0.5);
            display: flex;
            align-items: center;
            position: relative;
            width: auto;
            height: auto;
            padding: 2px 8px;
            border-radius: 1px;
            border-color: gray;
            border-style: solid;
            border-width: 1px 1px 1px 1px;
            opacity: 0.7;
            text-align: center;
            z-index: 500;
        }

        #leaflet-refresh-button:hover {
            opacity: 1;
            cursor: pointer;
            background-color: rgb(25, 25, 25);
        }

        .recenter-icon {
            background-image: url(./Data/mapIcons/map-Recenter.png);
            background-size: 26px 26px;
        }

        .leaflet-control-layers-scrollbar {
            scroll-behavior: smooth;
        }

        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }

        .legend {
            line-height: 18px;
            color: #555;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.85;
        }

        .leaflet-control{
            background-color: rgb(45, 45, 45, 0.5);
            color: rgb(255, 255, 255);
        }

        .leaflet-bar a{
            background-color: rgb(45, 45, 45, 0.5);
            color: rgb(255, 255, 255);
        }
        .leaflet-bar a:hover{
            background-color: rgb(25, 25, 25);
        }
        .leaflet-bar a:focus{
            background-color: rgb(25, 25, 25);
        }
        .leaflet-bar a.leaflet-disabled{
            background-color: rgb(45, 45, 45, 0.5);
        }

        .leaflet-container .leaflet-control-attribution{
            background-color: rgba(0, 0, 0, 0.8);
            color: rgb(255, 255, 255);
        }

        #sidebar-content {
            overflow-x: hidden;
            transition: opacity none;
        }

        #dropdown {
            width: 100%;
            top: 10px;
            position: absolute;
            font: 14px/16px Arial, Helvetica, sans-serif;
            z-index: 2600;
        }

        #dropdown-contents {
            position: absolute;
            width: 60%;
            left: 54px;
            overflow: hidden;
            height: 30px;
            padding: 4px 2px;
            background-color: rgb(0, 0, 0);
            color: rgb(255, 255, 255);
            border-radius: 5px;
            border-color: rgb(77, 77, 77);
            border-style: solid;
            border-width: 1px 1px 1px 1px;
            opacity: 0.7;
            text-align: center;
            z-index: 2200;
            font-size: 16px;
            font-family: inherit;
        }

        #dropdown-contents:hover {
            opacity: 1;
            cursor: pointer;
        }

        @media (max-width: 749px) {
            .sidebar {
                box-shadow: none;
                -webkit-border-radius: 0;
                border-radius: 0;
            }

            #dropdown {
                z-index: 2600;
            }

            #dropdown-contents {
                left: 20px;
                z-index: 2200;
            }
            #sidebar-content {
                padding-top: 50px;
            }
        }
        .leaflet-tooltip-left:before {
            right: 0;
            margin-right: -12px;
            border-left-color: rgba(0, 0, 0, 0);
        }
        .leaflet-tooltip-right:before {
            left: 0;
            margin-left: -12px;
            border-right-color: rgba(0, 0, 0, 0);
        }
        .leaflet-textTitle {
            position: absolute;
            padding: 1px 3px 1px 3px;
            background-color: rgba(200, 200, 200, 0.95);
            border: 0px solid #00000000;
            color: #000;
            white-space: nowrap;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            box-shadow: none;
        }
        .leaflet-pane{
            opacity: 1;
            transition: opacity 500ms;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="sidebar-right" class="sidebar"></div>
    <div id="sidebar-left" class="sidebar"></div>
    <div id="loading">
        <div id="progressBox">
            <div id="progressBg">
                <div id="progressBar"></div>
            </div>
        </div>
    </div>

    <script>// initialize the map

        //FUNCTIONS THAT CREATE AND RUN THE RLIIM QACH RRESH INTERACTIVE MAP PLAN
        //Jared Gingrich 2024

        //progress counter for loading the interactive plan
        var elem = document.getElementById("progressBar");
        const counter = {
            count: 0,
            update(count) {
                count = Math.round(count * 100) / 100;
                elem.style.width = count + "%";
                if (count >= 100) {
                    $('#loading').fadeOut(250);
                    var allFeatures = getAllFeatures(map);
                    if (allFeatures.length > 0) {
                        zoomToFeature(allFeatures, webID);
                    }
                }
            },
            get progress() {
                return this.count;
            },
            set progress(progress) {
                this.count = progress;
                this.update(this.count);
            }
        }

        //state counter for which aspect of the map is being displayed
        const state = {
            state: 'QachRresh',
            activeLayer: 'QachRresh_QachRresh',
            panes: {},
            bounds: mapbounds,
            center: 0,
            padding: 0,
            visiblePane(show, hide, delay = null) {
                if (delay == null) {
                    delay = 0;
                }
                var showArr = [];
                var hideArr = [];
                if (typeof show === 'string') {
                    showArr.push(show);
                } else {
                    showArr = show;
                }
                if (typeof hide === 'string') {
                    hideArr.push(hide);
                } else {
                    hideArr = hide;
                }
                setTimeout(function() {
                    hideArr.forEach(h => map.getPane(h + '-pane').style.opacity = 0);
                    showArr.forEach(s => map.getPane(s + '-pane').style.opacity = 1);
                    setTimeout(function() {
                        hideArr.forEach(h => map.getPane(h + '-pane').style.zIndex = 200);
                        showArr.forEach(s => map.getPane(s + '-pane').style.zIndex = 250);
                    }, 1000);
                }, delay);
            },
            update(select) {
                var hide = [];
                Object.keys(this.panes).forEach(p => {
                    if (p != select) {
                        hide.push(p);
                    }
                });
                if (Object.keys(layerCounter.controls).includes(select)) {
                    this.activeLayer = 'QachRresh_' + select;
                } 
                if (select == 'QachRresh') {
                    if (txt.texts != null) {
                        updateText(select);
                    }
                    map.setMaxZoom(21);
                    map.setMinZoom(17);
                    this.visiblePane(select, hide);
                    document.getElementById('leaflet-refresh-container').style.display = 'none';
                    map.addControl(layerCounter.controls[select]);

                    hide.forEach(h => map.removeControl(layerCounter.controls[h]));
                    if (roundWidth()[4] == 0) {
                        _sidebar.setSidebar('right', true);
                    }
                    updateWidth();
                    this.center = this.bounds.getCenter().lng;
                }
                else if (Object.keys(txt.texts).includes(select)) {
                    if (txt.texts != null) {
                        updateText(select);
                    }
                    map.setMaxZoom(24);
                    map.setMinZoom(21);
                    this.visiblePane(select, hide, 1000);
                    setTimeout(function() {
                        document.getElementById('leaflet-refresh-container').style.display = 'block';
                        map.addControl(layerCounter.controls[select]);
                        hide.forEach(h => map.removeControl(layerCounter.controls[h]));
                    }, 1500)
                    if (roundWidth()[4] == 0) {
                        if (this.bounds.getCenter().lng > this.center) {
                            _sidebar.setSidebar('left', true);
                        } else {
                            _sidebar.setSidebar('right', true);
                        }
                    }
                    updateWidth();
                }
                map.flyToBounds(this.bounds);
            },
            get select() {
                return this.state;
            },
            set select(select) {
                this.state = select;
                this.update(this.state);
            }
        }

        //checking orientation state, resetting on change
        const orientation = {
            orient: 'portrait',
            state: 'portrait',
            update(input) {
                this.state = input;
                updateWidth();
                var allFeatures = getAllFeatures(map);
                if (allFeatures.length > 0) {
                    map.invalidateSize();
                    zoomToFeature(allFeatures, webID);
                }
            },
            get size() {
                return this.orient;
            },
            set size(size) {
                this.orient = size;
                this.update(this.orient);
            }
        }        

        //shapfile loading counter, starting map on all shapefiles loaded
        const layerCounter = {
            shapes: {},
            tiles: {},
            layers: [],
            operations: {},
            controls: {},
            count: 0,
            target: 0,
            shape: null,
            shpCheck(shp) {
                if (shp.name == baseShapefile) {
                    this.baseShapefile = shp;
                    this.baseSet(baseShapefile.replace('QachRresh_', ''));
                }
                if (shp.name == contextsShapefile) {
                    this.operationShp = shp;
                }
            },
            baseSet(operation) {
                //set up panes, layercontrols, and texts
                map.createPane(operation + '-pane');
                map.getPane(operation + '-pane').style.zIndex = 200;
                this.layers.push({Description: operation, Url: url + operation + "/QachRresh_" + operation + '.txt'});
                this.controls[operation] = L.control.layers({}, null, { collapsed: false }).addTo(map);
                if ('QachRresh_' + operation == baseShapefile) {
                    state.panes[operation] = {Name: 'Qach Rresh', WebCode: 'QachRresh'};
                    this.baseShapefile.features.forEach(f => {
                        operation = f.properties.WebCode;
                        state.panes[f.properties.WebCode] = {Name: f.properties.Name, WebCode: f.properties.WebCode};
                        this.baseSet(operation);
                        years = f.properties.Years.split('/');
                        years.forEach(y => {
                            var tileUrl = extension + '/Data/mapTiles/' + operation + '_' + y + '/{z}/{x}/{y}.png';
                            this.operations['QachRresh_' + operation + '_' + y] = {Operation: operation, Year: y, tileUrl: tileUrl};
                        });
                    });
                    this.iteration++;
                }
            },
            update() {
                if (this.count == this.target) {
                    updateProgress(1, 4);
                    var tilegroups = [];
                    tileLayers.forEach(t => {
                        tilegroups.push(this.tiles[t]);
                    });
                    function opLayer(url, pane) {
                        url.options.maxZoom = 24;
                        url.options.minZoom = 17;
                        url.options.pane = pane
                        return url;
                    }
                    //adding basemaps to overall plan
                    addLayerGroups(
                        mapInput = map,
                        layerControl = layerCounter.controls['QachRresh'],
                        layers = tilegroups,
                        groups = generateLayerGroups({ groups: groups }),
                        functionOnLoad = function () {
                            getAllFeatures(map, true).forEach((v) => {
                                v.bindTooltipDelayed(v.feature.properties.Name, 
                                { sticky: true, className: 'leaflet-textTitle' });
                            });
                            divCreate(divName = dropdownName, //adding dropdown to map
                                divContainer = 'dropdown',
                                type = 'select',
                                functionOnCreate = function (newDiv) {
                                    //creating dropdown
                                    options = [dropdownOptions(state.panes)];
                                    options.forEach((option) => newDiv.innerHTML += option);
                                    //dropdown appearance/settings
                                    newDiv.addEventListener('change', onSelect);
                                    newDiv.title = "Select Monument Name to Zoom In";
                                }
                            ); 
                            txt.loadText(layerCounter.layers); //loading and formatting text descriptions for monuments
                            addRefresh(); //adding refresh button
                            addRecenterControl(); //adding recentering control to map
                            updateWidth(); //updating window width
                            map.invalidateSize(); //recentering map in window
                            map._size.x = roundWidth()[2];
                            state.bounds = mapbounds;
                        }
                    );
                    //Adding layers to map
                    Object.values(layerCounter.shapes).forEach((s) => {
                        //individual operations from combined operation layer
                        switch (s.name) {
                            case contextsShapefile:
                                Object.values(layerCounter.operations).forEach(o => {
                                    var newShp = {features: [], name: 'QachRresh_' + o.Operation + '_' + o.Year, type: 'FeatureCollection', layerName: 'QachRresh_' + o.Operation};
                                    layerCounter.operationShp.features.forEach(s => {
                                        if (s.properties.Operation == o.Operation && s.properties.Year == o.Year) {
                                            s.properties.layerName = 'QachRresh_' + o.Operation;
                                            newShp.features.push(s);
                                        }
                                    });
                                    //layerCounter.baseAddedLayers.push(newShp);
                                    var newGroup = L.layerGroup();
                                    var newLayer = L.geoJSON(newShp, {
                                        style: styleTransparent,
                                        onEachFeature: (feature, layer) => onEachFeature(feature, layer),
                                        pane: o.Operation + '-pane'
                                    }).addTo(newGroup);
                                    Object.values(newLayer._layers).forEach((v) => {
                                        v.bindTooltipDelayed(v.feature.properties.Name, 
                                        { sticky: true, className: 'leaflet-textTitle' });
                                        v.layerName = o.Operation;
                                    });
                                    var newTile = L.tileLayer(o.tileUrl, {
                                        tms: true
                                    });
                                    newTile.Name = o.Operation;
                                    newTile.Year = o.Year;
                                    opLayer(newTile, o.Operation + '-pane').addTo(newGroup);
                                    if (layerCounter.controls[o.Operation]._layers.length == 0) {
                                        layerCounter.controls[o.Operation].addBaseLayer(newGroup.addTo(map), o.Year);
                                    } else {
                                        layerCounter.controls[o.Operation].addBaseLayer(newGroup, o.Year);
                                    }
                                });
                                break;
                                //overall plan features for each operation
                            case baseShapefile:
                                var over = L.geoJSON(s, {
                                    style: styleOverlay,
                                    onEachFeature: (feature, layer) => onEachFeature(feature, layer, true, 0.1, true),
                                    pane: 'QachRresh-pane'
                                }).addTo(map);
                                getAllFeatures(over, true).forEach((v) => {
                                    v.bindTooltipDelayed(v.feature.properties.Name, 
                                    { sticky: true, className: 'leaflet-textTitle' });
                                    v.layerName = s.name;
                                    v.bringToFront();
                                });
                                break; 
                            //additional feature layers on overall map
                            default:
                                var over = L.geoJSON(s, {
                                    style: styleTransparent,
                                    pane: 'QachRresh-pane'
                                }).addTo(map);
                                getAllFeatures(over, true).forEach((v) => {
                                    v.bindTooltipDelayed(v.feature.properties.Name, 
                                    { sticky: true, className: 'leaflet-textTitle' });
                                    v.layerName = s.name;
                                    v.bringToBack();
                                });
                                break;
                        }
                    });
                    updateProgress(1, 4);
                }
            },
            get iteration() {
                return this.count;
            },
            set iteration(iteration) {
                this.count = iteration;
                this.update(this.count);
            }
        }

        //setting initial map variables
        var extension = '.';
        var shpFiles = [];
        var groups = [['Magnetometry', 'MAG'], ['Elevation Model', 'DEM']];
        var tileLayers = [extension + '/Data/mapTiles/DEM/{z}/{x}/{y}.png',
            extension + '/Data/mapTiles/MAG/{z}/{x}/{y}.png'];
        var shpLayers = ['https://cdn.rawgit.com/jagingrich/qachrresh_website/main/Data/mapFeatures/QachRresh_QachRresh.shp',
            'https://cdn.rawgit.com/jagingrich/qachrresh_website/main/Data/mapFeatures/QachRresh_Walls.shp',
            'https://cdn.rawgit.com/jagingrich/qachrresh_website/main/Data/mapFeatures/QachRresh_Operations.shp'];
        var dropdownName = 'dropdown-contents';

        //setting description creation vars
        var sidebarText = 'sidebar-content';
        var url = 'https://raw.githubusercontent.com/jagingrich/qachrresh_website/main/Data/mapDescriptions/';
        var defaultWebID = 'QachRresh';
        var baseShapefile = 'QachRresh_QachRresh';
        var contextsShapefile = 'QachRresh_Operations';
        var webID = defaultWebID;
        //var dropdownDefault = [];
        var remove = [];
        var replace = [];
        var width = 'width="' + roundWidth()[1] + 'px"';
        var w = window.innerWidth;

        //creating divs for parts of interactive plan
        const _sidebar = {
            side: 'right',
            setSidebar(show, transition) {
                hide = 'right';
                if (show == 'right') {
                    hide = 'left';
                } 
                document.getElementById('sidebar-' + hide).style.width = '0px';
                document.getElementById('sidebar-' + hide).style.padding = '0px';
                if (show != this.side) {
                    if (transition) {
                        document.getElementById('map').style.transition = 'left 1000ms';
                        Array.from(document.getElementsByClassName('sidebar')).forEach(s => {
                            s.style.transition = 'width 1000ms';
                        });
                    }
                    w = roundWidth();
                    this.side = show;
                    Array.from(document.getElementById('sidebar-' + hide).children).forEach(c => {
                        document.getElementById('sidebar-' + show).appendChild(c);
                    });
                    if (show == 'right') {
                        document.getElementById('map').style.left = '0px';
                        Array.from(document.getElementById('sidebar-' + show).children).forEach(c => {
                            c.style.transform = null;
                        });
                    } else {
                        document.getElementById('map').style.left = w[0] + 'px';
                        Array.from(document.getElementById('sidebar-' + show).children).forEach(c => {
                            c.style.transform = 'scaleX(-1)';
                        });
                    }
                    document.getElementById('sidebar-' + show).style.width = w[0] + 'px';
                    document.getElementById('sidebar-' + show).style.padding = '10px';
                    setTimeout(function () {
                        document.getElementById('map').style.transition = null;
                        Array.from(document.getElementsByClassName('sidebar')).forEach(s => {
                            s.style.transition = null;
                        });
                    }, 1001);
                    
                }
            }
        };

        divCreate('dropdown', 'map');
        divCreate(sidebarText, 'sidebar-' + _sidebar.side);

        //creating map bounds
        var mapbounds = L.latLngBounds(L.latLng(33.7878, -84.3238), L.latLng(33.78954, -84.3228));

        //creating map variable
        var map = L.map('map', {
            center: [33.7887, -84.3233],
            zoom: 16
        });

        //function to add elements to map attribution
        function addAttribution(text, title, href) {
            var att = document.getElementsByClassName('leaflet-control-attribution')[0];
            att.innerHTML += ' | ';
            var newAtt;
            if (href) {
                newAtt = document.createElement('a');
                newAtt.href = href;
            } else {
                newAtt = document.createElement('text');
            }
            newAtt.innerHTML = text;
            if (title) {
                newAtt.title = title;
            }
            att.appendChild(newAtt);
        }
        addAttribution('JAG2024');
        addAttribution('RLIIM', 'Rural Landscapes of Iron Age Imperial Mesopotamia', 'https://scholarblogs.emory.edu/rliim/');


        //setting bounds on load
        state.padding = 0.1;
        map.flyToBounds(mapbounds.pad(state.padding));
        map.setMaxBounds(mapbounds.pad(1));
        state.bounds = mapbounds;

        //reading in shapefiles
        layerCounter.target = shpLayers.length + tileLayers.length + 1;
        shpLayers.forEach(s => readSHPs(s));

        //loading tile layers
        function loadTiles(tiles) {
            tiles.forEach(t => {
                layerCounter.tiles[t] = L.tileLayer(t, {
                    tms: true
                });
                var name = t.split('/mapTiles/')[1];
                name = name.split('/')[0];
                name = name.split('_');
                layerCounter.tiles[t].Name = name[0];
                layerCounter.tiles[t].Year = name[1];
                layerCounter.iteration++;
                updateProgress(1 / tiles.length, 4);
            });
        }
        loadTiles(tileLayers);
        
        //listening for width change
        ['resize', 'focus'].forEach(function (e) {
            window.addEventListener(e, function () {
            updateWidth();
                setTimeout(function () {
                    var orientate = 'landscape';
                    if (window.innerWidth < window.innerHeight) {
                        orientate = 'portrait';
                    }
                    if (orientate != orientation.state) {
                        orientation.size = orientate;
                        document.getElementById('map').style.transition = null;
                        Array.from(document.getElementsByClassName('sidebar')).forEach(s => {
                            s.style.transition = null;
                        });
                    }
                }, 100);
            });
        });

        L.Layer.include({
            bindTooltipDelayed: function (content, options) {
                if (content instanceof L.Tooltip) {
                    L.setOptions(content, options);
                    this._tooltip = content;
                    content._source = this;
                } else {
                    if (!this._tooltip || options) {
                        this._tooltip = new L.Tooltip(options, this);
                    }
                    this._tooltip.setContent(content);
                }
                this._initTooltipInteractionsDelayed();
                return this;
            },
            _initTooltipInteractionsDelayed: function () {
                this.timer = null;
                this.lat_lang = null;
                this.on('mouseover', startTimer);
                this.on('mousemove', hoverTimer);
                this.on('click', stopTimer);
                this.on('mouseout', stopTimer);
        
                function stopTimer (e, me = null) {
                    if (e.type == 'click') {
                        var tt = this._tooltip;
                        this.unbindTooltip();
                        this._tooltip = tt;
                    }            
                    var out = this;
                    if (this == window && me != null) {
                        out = me;
                    }
                    clearTimeout(out.timer);
                    out.closeTooltip();
                }
                function startTimer (e) {
                    if(e.target.feature.properties.layerName == state.activeLayer) {
                        this.timer = setTimeout(function() {}, 500);
                    }
                }
                function hoverTimer (e) {
                    if (e.target.feature.properties.layerName == state.activeLayer) {
                        var lat_lang = e.latlng;
                        clearTimeout(this.timer);
                        stopTimer(e, this);
                        var out = this;
                        this.timer = setTimeout(function() {
                            out.bindTooltip(out._tooltip._content).openTooltip(lat_lang);
                        }, 500);
                    }
                }
            }
        });

        //creating divs for parts of interactive plan in map, overlay divs
        function divCreate(divName, divContainer, type = 'div', functionOnCreate = null) {
            L.Control.newDiv = L.Control.extend({
                addTo: function (placeholder) {
                    // Attach new div to input container
                    var container = L.DomUtil.get(placeholder);
                    var newDiv = L.DomUtil.create(type, divName, container);
                    L.DomEvent.disableClickPropagation(newDiv);
                    newDiv.id = divName;

                    if (functionOnCreate != null && typeof (functionOnCreate) == 'function') {
                        functionOnCreate(newDiv);
                    }           

                    return this;
                },
                onRemove: function (placeholder) { }
            });
            var outDiv = new L.Control.newDiv();
            outDiv.addTo(divContainer);
        }

        //formatting for tile layers
        function tileLayer(url) {
            url.options.maxZoom = 22;
            url.options.minZoom = 17;
            url.options.pane = 'QachRresh-pane';
            return url;
        }

        //formatting for json overlay layers
        function jsonLayer(json) {
            return L.geoJSON(json, {
                style: styleTransparent,
                onEachFeature: onEachFeature
            });
        }

        //transparent overlay layer style
        function styleTransparent() {
            return {
                fillColor: '#00000000',
                weight: 1.5,
                opacity: 0.85,
                color: '#FFF',
                fillOpacity: 0
            }
        }

        //operations overlay layer style
        function styleOverlay() {
            return {
                fillColor: '#059FDC',
                weight: 2.5,
                opacity: 0.85,
                color: '#059FDC',
                fillOpacity: 0.3
            }
        }

        //mouseover highlight behavior and highlight reset
        function highlightFeature(e) {
            e.target.setStyle({
                fillColor: '#FFF',
                weight: 2.5,
                opacity: 1,
                color: '#FFF',
                dashArray: '',
                fillOpacity: 0.25
            });

            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                e.target.bringToFront();
            }
        }

        //mouseover overlay highlight behavior and highlight reset
        function highlightOverlayFeature(e) {
            e.target.setStyle({
                fillColor: '#059FDC',
                weight: 3,
                opacity: 1,
                color: '#059FDC',
                dashArray: '',
                fillOpacity: 0.50
            });

            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                e.target.bringToFront();
            }
        }

        //this is the reset
        function resetHighlight(e) {
            e.target.setStyle(styleTransparent());
        }

        //this is the overlay reset
        function resetOverlayHighlight(e) {
            e.target.setStyle(styleOverlay());
        }

        //zoom to feature from given code
        function zoomToFeature(features, webCode) {
            if (webCode != defaultWebID) {
                //select objects
                var selected = [];
                features.forEach(function (f) {
                    if (f.properties.WebCode == webCode) {
                        selected.push(L.geoJSON(f));
                    }
                });

                //zoom to bounds
                map.flyToBounds(L.featureGroup(selected).getBounds().pad(state.padding));
            }
            else {
                //zoom to all map bounds
                map.flyToBounds(mapbounds.pad(state.padding));
            }
        }

        //selecting feature: click or dropdown
        function selectFeature(webCode, fitZoom = false, padding = 0) {
            //check if clicked on active layer
            if (webCode.type == 'click') {
                webCode = webCode.target;
                var layer = webCode.layerName.replace('QachRresh_', '');
                layer = layer.split('_')[0];
                if('QachRresh_' + layer == state.activeLayer) {
                    //zoom to selection
                    if (padding != 0) {
                        state.padding = padding;
                    }
                    if (fitZoom) {
                        state.bounds = webCode.getBounds();
                        map.setMaxBounds(webCode.getBounds().pad(1));
                    }
                    state.select = webCode.feature.properties.WebCode;
                    map.flyToBounds(webCode.getBounds().pad(padding));
                }
            } else if (webCode.type == 'select') {
                //zoom to selection
                if (padding != 0) {
                    state.padding = padding;
                }
                if (fitZoom) {
                    state.bounds = webCode.getBounds();
                    map.setMaxBounds(webCode.getBounds().pad(1));
                }
                state.select = webCode.WebCode;
                map.flyToBounds(webCode.getBounds().pad(padding));
            }
        }

        //layer responsiveness
        function onEachFeature(feature, layer, fitZoom = false, padding = 0, overlay = false) {
            if (overlay) {
                layer.on({
                    mouseover: highlightOverlayFeature,
                    mouseout: resetOverlayHighlight,
                    click: (e, event) => selectFeature(e, fitZoom, padding)
                });
            } else {
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight,
                    click: (e, event) => selectFeature(e, fitZoom, padding)
                });
            }
        }

        //on changing dropdown selection
        function onSelect() {
            var dropdown = document.getElementById(dropdownName);
            var index = dropdown.options.selectedIndex;
            var feature;
            var padding = 0;
            if (dropdown[index].value == defaultWebID) {
                feature = L.geoJSON(layerCounter.baseShapefile);
                padding = 0.1;
            } else {
                layerCounter.baseShapefile.features.forEach(f => {
                    if (f.properties.WebCode == dropdown[index].value) {
                        feature = L.geoJSON(f);
                        feature = Object.values(feature._layers)[0];
                    }
                });
            }
            feature.type = "select";
            feature.layerName = "QachRresh_QachRresh";
            feature.WebCode = dropdown[index].value;
            selectFeature(feature, true, padding);
        }

        //updating text and dropdown selection
        function updateText(webCode) {
            //update text output code
            webID = webCode;
            updateOutput(sidebarText, webID);
            updateWidth();

            //update dropdown
            if (document.getElementById(dropdownName)) {
                var dropdown = document.getElementById(dropdownName);
                dropdown.value = webID;
            }
        }

        //finding all features in map
        function getAllFeatures(inputs, leaflet = false) {
            var feats = [];
            function checkLayers(obj, out) {
                if (Object.keys(obj).includes('_layers')) {
                    Object.values(obj._layers).forEach(function (f) {
                        if (Object.keys(f).includes('feature') && !out.includes(f.feature)) {
                            if (leaflet) {
                                out.push(f);
                            } else {
                                out.push(f.feature);
                            }                            
                        }
                    });
                }
            }
            function checkInputs(obj) {
                if (Array.isArray(obj._layers)){
                    obj._layers.forEach((l) => {
                        Object.values(l.layer._layers).forEach(function (s) {
                            checkLayers(s, feats);
                        });
                    });
                } else if (typeof (obj) == 'object') {
                    checkLayers(obj, feats);
                }
            }
            if (Array.isArray(inputs)){
                inputs.forEach((i) => {
                    checkInputs(i);
                });
            } else if (typeof (inputs) == 'object') {
                checkInputs(inputs);
            }
            return feats;
        }

        //layer groups from names and keywords
        function generateLayerGroups({ groups = [[groupName = null, keyword = null]] }) {
            var laygroups = []
            groups.forEach(function (g) {
                laygroups.push({ name: g[0], keyword: g[1], layers: L.layerGroup() });
            });
            laygroups.push({ name: 'Other', keyword: 'Missing', layers: L.layerGroup() });
            return laygroups;
        }

        function addLayerGroups(mapInput, layerControl, layers, groups, functionOnLoad = null) {
            //type of layers
            var tiles = [];
            var shps = [];
            layers.forEach(function (l) {
                if (l._url.match('{z}/{x}/{y}.png') != null) {
                    tiles.push(l);
                }
                if (l.type == "FeatureCollection") {
                    shps.push(l);
                }
            });

            //add layerGroups to map
            function addLayers(mapInput, layerGroups, layerControl) {
                var count = 0;
                if (layerControl != null) {
                    groups.forEach(function (g) {
                        if (g.name != 'Other') {
                            if (count == 0) {
                                layerControl.addBaseLayer(g.layers.addTo(mapInput), g.name);
                                count++;
                            }
                            else {
                                layerControl.addBaseLayer(g.layers, g.name);
                            }
                        }
                        if (g.name == 'Other') {
                            g.layers.addTo(mapInput);
                        }
                    })
                } else {
                    groups.forEach(function (g) {
                        g.layers.addTo(mapInput);
                    })
                }
            }

            //tile layers to groups
            tiles.forEach(function (t) {
                var match = false;
                groups.forEach(function (g) {
                    if (g.name != 'Other') {
                        if (t._url.match(g.keyword) != null) {
                            tileLayer(t).addTo(g.layers);
                            match = true;
                        }
                    }
                    if (g.name == 'Other') {
                        out = t;
                        groups.forEach((gs) => {
                            if (gs.keyword != 'Missing') {
                                if (t._url.match(gs.keyword) != null) {
                                    out = null;
                                }
                            }
                        });
                        if (out != null) {
                            tileLayer(t).addTo(map);
                        }
                    }
                });
                if (!match) {
                    tileLayer(t).addTo(groups[groups.findIndex((element) => element.name == "Other")].layers)
                }
            });

            //shp layers to groups
            shps.forEach(function (s) {
                var match = false;
                groups.forEach(function (g) {
                    if (g.name != 'Other') {
                        if (s.name.match(g.keyword) != null) {
                            jsonLayer(s).addTo(g.layers);
                            match = true;
                        }
                    }
                });
                if (!match) {
                    jsonLayer(s).addTo(groups[groups.findIndex((element) => element.name == "Other")].layers)
                }
            });
            addLayers(mapInput, groups, layerControl);

            if (functionOnLoad != null && typeof (functionOnLoad) == 'function') {
                functionOnLoad();
            }
        }

        //ajax request for SHPfile data
        function readSHPs(url) {
            url = url.replaceAll('.shp', '');
            var name = url.split('/')[url.split('/').length - 1];
            $.ajax({
                url: url + '.shp',
                type: "head",
                success: function () {
                    shp(url).then(function (out) {
                        out.name = name;
                        var operation;
                        var years;
                        out.features.forEach(f => {
                            f.properties.layerName = out.name;
                        });
                        layerCounter.shapes[out.name] = out;
                        layerCounter.shpCheck(out);
                        layerCounter.iteration++;
                    });
                },
                error: function () {
                    layerCounter.iteration++;
                }
            });
        }

        //creating legend
        function addLegend() {
            var legend = L.control({ position: 'bottomleft' });
            legend.onAdd = function (map) {

                var div = L.DomUtil.create('div', 'info legend'),
                    grades = [1, 2, 3, 4, 5, 6],
                    labels = ['Late fifth to early fourth century BCE',
                        'Late fourth century BCE',
                        'Third century BCE',
                        'Second to first century BCE',
                        'First to second century CE',
                        'Post Antique'];

                for (var i = 0; i < grades.length; i++) {
                    div.innerHTML +=
                        '<i style="background:' + getColor(grades[i]) + '"></i> ' + labels[i] + '<br>';
                }

                return div;
            };

            //phasing and legend colors
            function getColor(d) {
                return d == "1" ? '#94d1e7' :
                    d == "2" ? '#007abc' :
                    d == "3" ? '#00a33c' :
                    d == "4" ? '#ff871f' :
                    d == "5" ? '#ff171F' :
                    d == "6" ? '#fdf500' :
                            '#00000000';
            }

            legend.addTo(map);
        }

        //creating refresh button control
        function addRefresh() {
            L.Control.Button = L.Control.extend({
                options: {
                    position: 'topright'
                },
                onAdd: function (map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                    var button = L.DomUtil.create('a', 'leaflet-control-button', container);
                    L.DomEvent.disableClickPropagation(button);
                    L.DomEvent.on(button, 'click', function () {
                        state.bounds = mapbounds;
                        state.padding = 0.1;
                        map.setMaxBounds(mapbounds.pad(1));
                        state.select = "QachRresh";
                    });

                    container.id = "leaflet-refresh-container";
                    button.id = "leaflet-refresh-button";
                    button.title = "Zoom Out to Site Map";
                    button.innerHTML = 'View Site';

                    return container;
                },
                onRemove: function (map) { },
            });
            var control = new L.Control.Button();
            control.addTo(map);
        }

        //creating recenter button control
        function addRecenterControl() {
            leaflet.Control.Recenter = leaflet.Control.extend({
                options: {
                    position: 'topleft',
                    title: 'Recenter'
                },
                _createButton: function (title, className, content, container, context) {
                    this.link = leaflet.DomUtil.create('a', className, container);
                    this.link.href = '#';
                    this.link.title = title;
                    this.link.innerHTML = content;

                    this.link.setAttribute('role', 'button');
                    this.link.setAttribute('aria-label', title);

                    L.DomEvent.disableClickPropagation(container);

                    L.DomEvent.on(this.link, 'click', function () {
                        map.flyToBounds(state.bounds.pad(state.padding));
                    });

                    return this.link;
                },

                onAdd: function (map) {
                    var className = 'leaflet-control-zoom-selection', container, content = '';

                    container = map.zoomControl._container;

                    if (this.options.content) {
                        content = this.options.content;
                    } else {
                        className += ' recenter-icon';
                    }

                    this._createButton(this.options.title, className, content, container, this);
                    this._map.recenter = this;

                    return container;
                }
            })
            var zoomTo = new L.Control.Recenter();
            zoomTo.addTo(map);
        }

        //creating listener for screen width change & update accordingly
        function roundWidth() {
            const q = window.innerWidth;
            const tops = Array.from(document.getElementsByClassName('leaflet-top'));
            var topWidth = 10 * tops.length;
            tops.forEach((f) => topWidth += f.clientWidth);
            if (window.innerWidth < window.innerHeight) {
                return [q, q - 40, q, q - 40, 1];
            }
            else {
                return q < 750 ? [q, q - 40, q, q - 40, 1] :
                    q < 900 ? [355, 315, q - 355, q - 335 - 180 - 100, 0] :
                    q < 1050 ? [425, 385, q - 425, q - 425 - 180 - 80, 0] :
                    q < 1200 ? [490, 450, q - 490, q - 490 - 180 - 60, 0] :
                    q < 1350 ? [550, 510, q - 550, q - 550 - 180 - 40, 0] :
                                [605, 565, q - 605, q - 605 - 180 - 20, 0];
            }
        }

        function updateWidth() {
            var oldWidth = width;
            var w = roundWidth();
            width = 'width="' + w[1] + 'px"'; 
            if (_sidebar.side == 'left') {
                document.getElementById('map').style.left = w[0] + 'px';
            }
            document.getElementById('map').style.width = w[2] + 'px';
            document.getElementById('sidebar-' + _sidebar.side).style.width = w[0] + 'px';
            if (document.getElementById(sidebarText)) {
                Array.from(document.getElementsByClassName('image')).forEach((i) => {
                    i.style.width = w[1] + 'px';
                });
                document.getElementById(sidebarText).style.width = w[1] + 'px';
            }
            if (document.getElementById(dropdownName)) {
                if (w[4] == 0) {
                    if (!document.getElementById('dropdown').firstChild) {
                        var dd = document.getElementById('sidebar-' + _sidebar.side).firstChild;
                        dd.style.transform = null;
                        document.getElementById('dropdown').appendChild(dd);
                        if (state.bounds.getCenter().lng > state.center) {
                            _sidebar.setSidebar('left');
                        } else {
                            _sidebar.setSidebar('right');
                        }
                    }
                    document.getElementById(dropdownName).style.left = (w[3] / 2) + 'px';
                    document.getElementById(dropdownName).style.width = '180px';
                }
                if (w[4] == 1) {
                    if (document.getElementById('dropdown').firstChild) {
                        var dd = document.getElementById('dropdown').firstChild;
                        var fc = document.getElementById('sidebar-' + _sidebar.side).firstChild;
                        document.getElementById('sidebar-' + _sidebar.side).insertBefore(dd, fc);
                        _sidebar.setSidebar('right');
                    }
                    document.getElementById(dropdownName).style.left = '20px';
                    document.getElementById(dropdownName).style.width = w[1] + 'px';
                }
            }
        }

        //function for unique features from JSON input
        function uniqueFeatures(features, id, sort = null, sortType = 'Number') {
            var feats = [];
            var ids = [];
            features.forEach(function (f) {
                if (!ids.includes(f.properties[id])) {
                    feats.push(f);
                    ids.push(f.properties[id])
                }
            });
            if (sort != null) {
                function fixSortKey(input) {
                    switch (sortType) {
                        case 'Number':
                            var out = input;
                            out = out.split("-")[0];
                            out = out.replace("a", ".2");
                            out = out.replace("b", ".5");
                            return Number(out);
                        case 'String':
                            return String(input);
                        default:
                            return input;
                    }
                }
                feats.sort(function (a, b) {
                    var keyA = fixSortKey(a.properties[sort]);
                    var keyB = fixSortKey(b.properties[sort]);
                    if (keyA < keyB) return -1;
                    if (keyA > keyB) return 1;
                    return 0;
                });
            }
            return feats;
        }

        //generating dropdown menu options from JSON inputs
        function dropdownOptions(inputs) {
            var optionsOut = [];
            Object.values(inputs).forEach((f) => optionsOut.push('<option value="' + f.WebCode + '">' + f.Name + '</option>'))
            return optionsOut;
        }

        //html formating for text strings

        //creating text reader/formatter
        const txt = formatText.newFormat();

        //setting format parameters
        txt.defaultOptions = {fontSize: '14px'};
        txt.remove = remove;
        txt.replace = replace;
        txt.imageCode = 'Caption';
        txt.addCategory('Title', {fontSize: '30px', fontWeight: 'bold'});
        txt.addCategory('Monument', {fontSize: '30px', fontWeight: 'bold'});
        txt.addCategory('Header', {fontSize: '24px', fontWeight: 'bold'});
        txt.addCategory('Subheader', {fontWeight: 'bold'});
        txt.addCategory('Part', {fontWeight: 'bold'});
        txt.addCategory('Bibliography', {fontSize: '18px', fontWeight: 'bold'}, {fontSize: '11px', textIndent: '-36px', paddingLeft: '36px'});
        txt.addCategory('Date', {fontSize: '11px'});
        txt.addCategory('Material', {fontSize: '11px'});
        txt.addCategory('Location', {fontSize: '11px'});
        txt.addCategory('Caption', {fontSize: '11px'});
        txt.addCategory('_footer', {fontSize: '10px'});
        txt.addCategory('_default', {}, {}, false);
        txt.addCategory('_space', {height: '20px'}, {}, false);
        txt._onLoad = function () {
            updateProgress(1, 4);
            state.select = 'QachRresh';
            updateWidth(); //updating window width
        }   

        //reseting scroll position on layer click
        function resetScroll() {
            window.setTimeout(() => {
                document.getElementById("sidebar-right").scrollTop = 0;
            }, 1);
        }

        //packaged function for updating sidebar output
        function updateOutput(updateDiv, desc) {
            //loading text to sidebar
            if (document.getElementById(updateDiv).firstChild) {
                document.getElementById(updateDiv).firstChild.remove();
            }
            document.getElementById(updateDiv).appendChild(txt.texts[desc].Div.cloneNode(true));
            //reset scroll position
            setTimeout(function () {
                resetScroll();
            }, 10);
        }

        //updating progress bar as layers/descriptions load
        function updateProgress(increase, parts) {
            var id = setInterval(frame, 10);
            var iter = 0;
            function frame() {
                if (iter < 100) {
                    counter.progress += increase / parts;
                    iter++;
                } else {
                    clearInterval(id);
                }
            }
        }
    </script>
</body>
</html>
